{"version":3,"sources":["jenks.js"],"names":["jenks","noDataValue","grid","nBreaks","sample","data","length","slice","Int32Array","generator","west","north","width","height","i","random","filter","ssJenks","ssJenksMatrices","nClasses","lowerClassLimits","varianceCombinations","j","variance","tmp1","tmp2","push","Infinity","l","sum","sumSquares","w","i4","m","lowerClassLimit","val","sort","a","b","matrices","k","kclass","countNum"],"mappings":"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","file":"jenks.js","sourcesContent":["import { constructor as XorShift } from 'xorshift'\n\n/**\n * https://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization\n * Algorithm implemented in Javascript by Tom McWright.\n * http://www.macwright.org/2013/02/18/literate-jenks.html\n */\nconst jenks = ({ noDataValue = null }) => (grid, nBreaks) => {\n  // Use a sample of the data to make the Jenks optimization algorithm tractable.\n  let sample\n  if (grid.data.length < 10000) {\n    sample = grid.data.slice(0)\n  } else {\n    sample = new Int32Array(10000)\n    const generator = new XorShift([grid.west, grid.north, grid.width, grid.height])\n    for (let i = 0; i < 10000; i++) {\n      sample[i] = grid.data[(generator.random() * grid.data.length) | 0]\n    }\n  }\n  sample = sample.filter(i => i !== noDataValue)\n  // If you call simple-statistics Jenks breaks requesting N classes,\n  // you'll receive N+1 breaks including the lower and upper ends.\n  // We remove the initial lower boundary (our lower boundary is -inf).\n  return ssJenks(sample, nBreaks).slice(1)\n}\n\nexport default jenks\n\n/*\n\nThe code below this point is derived from simple-statistics project.\nFor some reason it's no longer included in that project, so I've copied it here.\n\nCopyright (c) 2014, Tom MacWright\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n\n*/\n\n// Compute the matrices required for Jenks breaks. These matrices\n// can be used for any classing of data with `classes <= nClasses`\nconst ssJenksMatrices = function (data, nClasses) {\n  // in the original implementation, these matrices are referred to\n  // as `LC` and `OP`\n  //\n  // * lowerClassLimits (LC): optimal lower class limits\n  // * varianceCombinations (OP): optimal variance combinations for all classes\n  let lowerClassLimits = []\n  let varianceCombinations = []\n  // loop counters\n  let i\n  let j\n  // the variance, as computed at each step in the calculation\n  let variance = 0\n\n  // Initialize and fill each matrix with zeroes\n  for (i = 0; i < data.length + 1; i++) {\n    let tmp1 = []\n    let tmp2 = []\n    for (j = 0; j < nClasses + 1; j++) {\n      tmp1.push(0)\n      tmp2.push(0)\n    }\n    lowerClassLimits.push(tmp1)\n    varianceCombinations.push(tmp2)\n  }\n\n  for (i = 1; i < nClasses + 1; i++) {\n    lowerClassLimits[1][i] = 1\n    varianceCombinations[1][i] = 0\n    // in the original implementation, 9999999 is used but\n    // since Javascript has `Infinity`, we use that.\n    for (j = 2; j < data.length + 1; j++) {\n      varianceCombinations[j][i] = Infinity\n    }\n  }\n\n  for (let l = 2; l < data.length + 1; l++) {\n    // `SZ` originally. this is the sum of the values seen thus\n    // far when calculating variance.\n    let sum = 0\n    // `ZSQ` originally. the sum of squares of values seen\n    // thus far\n    let sumSquares = 0\n    // `WT` originally. This is the number of\n    let w = 0\n    // `IV` originally\n    let i4 = 0\n\n    // in several instances, you could say `Math.pow(x, 2)`\n    // instead of `x * x`, but this is slower in some browsers\n    // introduces an unnecessary concept.\n    for (let m = 1; m < l + 1; m++) {\n      // `III` originally\n      let lowerClassLimit = l - m + 1\n      let val = data[lowerClassLimit - 1]\n\n      // here we're estimating variance for each potential classing\n      // of the data, for each potential number of classes. `w`\n      // is the number of data points considered so far.\n      w++\n\n      // increase the current sum and sum-of-squares\n      sum += val\n      sumSquares += val * val\n\n      // the variance at this point in the sequence is the difference\n      // between the sum of squares and the total x 2, over the number\n      // of samples.\n      variance = sumSquares - (sum * sum) / w\n\n      i4 = lowerClassLimit - 1\n\n      if (i4 !== 0) {\n        for (j = 2; j < nClasses + 1; j++) {\n          if (varianceCombinations[l][j] >= (variance + varianceCombinations[i4][j - 1])) {\n            lowerClassLimits[l][j] = lowerClassLimit\n            varianceCombinations[l][j] = variance + varianceCombinations[i4][j - 1]\n          }\n        }\n      }\n    }\n\n    lowerClassLimits[l][1] = 1\n    varianceCombinations[l][1] = variance\n  }\n\n  return {\n    lowerClassLimits: lowerClassLimits,\n    varianceCombinations: varianceCombinations\n  }\n}\n\nconst ssJenks = function (data, nClasses) {\n  // sort data in numerical order\n  data = data.slice().sort(function (a, b) { return a - b })\n\n  // get our basic matrices\n  let matrices = ssJenksMatrices(data, nClasses)\n  // we only need lower class limits here\n  let lowerClassLimits = matrices.lowerClassLimits\n  let k = data.length - 1\n  let kclass = []\n  let countNum = nClasses\n\n  // the calculation of classes will never include the upper and\n  // lower bounds, so we need to explicitly set them\n  kclass[nClasses] = data[data.length - 1]\n  kclass[0] = data[0]\n\n  // the lowerClassLimits matrix is used as indexes into itself\n  // here: the `k` variable is reused in each iteration.\n  while (countNum > 1) {\n    kclass[countNum - 1] = data[lowerClassLimits[k][countNum] - 2]\n    k = lowerClassLimits[k][countNum] - 1\n    countNum--\n  }\n  return kclass\n}\n"]}