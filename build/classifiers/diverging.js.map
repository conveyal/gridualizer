{"version":3,"sources":["diverging.js"],"names":["diverging","scheme","center","opts","grid","nBreaks","breaksPerSide","dataBelow","data","filter","i","dataAbove","classifier","breaksBelow","length","max","Math","min","slice","map","breaksAbove"],"mappings":";;;;;;;;;;;;;;;;;;AAEA;;;;AACA;;;;;;AAEA;;;;;;AALA;;AAWA,IAAMA,YAAY,SAAZA,SAAY;AAAA,iFAA2C,EAA3C;;AAAA,yBAAGC,MAAH;AAAA,MAAGA,MAAH;AAAA,yBAAmBC,MAAnB;AAAA,MAAmBA,MAAnB,+BAA4B,CAA5B;AAAA,MAAkCC,IAAlC;AAAA,SAAkD,UAACC,IAAD,EAAOC,OAAP,EAAmB;AACrF,QAAIA,UAAU,CAAV,KAAgB,CAApB,EAAuBA,UAD8D,CACpD;;AAEjC,QAAMC,gBAAgB,CAACD,UAAU,CAAX,IAAgB,CAAtC;;AAEA,QAAME,YAAYH,KAAKI,IAAL,CAAUC,MAAV,CAAiB;AAAA,aAAKC,IAAIR,MAAT;AAAA,KAAjB,CAAlB;AACA,QAAMS,YAAYP,KAAKI,IAAL,CAAUC,MAAV,CAAiB;AAAA,aAAKC,IAAIR,MAAT;AAAA,KAAjB,CAAlB;;AAEA,QAAMU,aAAaX,OAAOE,IAAP,CAAnB;AACA,QAAMU,cAAcN,UAAUO,MAAV,GAAmB,CAAnB,GAChBF,sCAAgBR,IAAhB,IAAsBI,MAAMD,SAA5B,EAAuCQ,KAAKC,KAAKC,GAAL,CAASb,KAAKW,GAAd,EAAmBb,MAAnB,CAA5C,KAA0EI,aAA1E,EAAyFY,KAAzF,CAA+F,CAA/F,EAAkGZ,gBAAgB,CAAlH,CADgB,GAEhB,qBAAMA,gBAAgB,CAAtB,EAAyBa,GAAzB,CAA6B;AAAA,aAAKjB,MAAL;AAAA,KAA7B,CAFJ;AAGA,QAAMkB,cAAcT,UAAUG,MAAV,GAAmB,CAAnB,GAChBF,sCAAgBR,IAAhB,IAAsBI,MAAMG,SAA5B,EAAuCM,KAAKD,KAAKD,GAAL,CAASX,KAAKa,GAAd,EAAmBf,MAAnB,CAA5C,KAA0EI,aAA1E,CADgB,GAEhB,qBAAMA,aAAN,EAAqBa,GAArB,CAAyB;AAAA,aAAKjB,MAAL;AAAA,KAAzB,CAFJ;;AAIA,sDAAWW,WAAX,oCAA2BO,WAA3B;AACD,GAjBiB;AAAA,CAAlB;;kBAmBepB,S","file":"diverging.js","sourcesContent":["/** Create a diverging scale from another scale */\n\nimport equal from './equal-interval'\nimport range from 'lodash/range'\n\n/**\n * Create a diverging classifier from any other classifier,\n * set scheme to the other classifier.\n * If the center is not zero, specify the center parameter.\n * If the classifier you are using requires other options, pass them in as well.\n */\nconst diverging = ({ scheme = equal, center = 0, ...opts } = {}) => (grid, nBreaks) => {\n  if (nBreaks % 2 === 0) nBreaks-- // we need an odd number of clases\n\n  const breaksPerSide = (nBreaks + 1) / 2\n\n  const dataBelow = grid.data.filter(i => i < center)\n  const dataAbove = grid.data.filter(i => i > center)\n\n  const classifier = scheme(opts)\n  const breaksBelow = dataBelow.length > 0\n    ? classifier({ ...grid, data: dataBelow, max: Math.min(grid.max, center) }, breaksPerSide).slice(0, breaksPerSide - 1)\n    : range(breaksPerSide - 1).map(i => center)\n  const breaksAbove = dataAbove.length > 0\n    ? classifier({ ...grid, data: dataAbove, min: Math.max(grid.min, center) }, breaksPerSide)\n    : range(breaksPerSide).map(i => center)\n\n  return [...breaksBelow, ...breaksAbove]\n}\n\nexport default diverging\n"]}