{"version":3,"sources":["quantile.js"],"names":["quantile","noDataValue","grid","nBreaks","sample","data","length","slice","Int32Array","generator","west","north","width","height","i","random","filter","sort","step","breaks","push","max"],"mappings":";;;;;;AAAA;;AAEA;AACA,IAAMA,WAAW,SAAXA,QAAW;AAAA,8BAAGC,WAAH;AAAA,MAAGA,WAAH,oCAAiB,IAAjB;AAAA,SAA4B,UAACC,IAAD,EAAOC,OAAP,EAAmB;AAC9D,QAAIC,eAAJ;AACA;AACA;AACA,QAAIF,KAAKG,IAAL,CAAUC,MAAV,GAAmB,KAAvB,EAA8B;AAC5BF,eAASF,KAAKG,IAAL,CAAUE,KAAV,CAAgB,CAAhB,CAAT;AACD,KAFD,MAEO;AACLH,eAAS,IAAII,UAAJ,CAAe,KAAf,CAAT;AACA,UAAMC,YAAY,0BAAa,CAACP,KAAKQ,IAAN,EAAYR,KAAKS,KAAjB,EAAwBT,KAAKU,KAA7B,EAAoCV,KAAKW,MAAzC,CAAb,CAAlB;AACA,WAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAI,KAApB,EAA2BA,GAA3B,EAAgC;AAC9BV,eAAOU,CAAP,IAAYZ,KAAKG,IAAL,CAAWI,UAAUM,MAAV,KAAqBb,KAAKG,IAAL,CAAUC,MAAhC,GAA0C,CAApD,CAAZ;AACD;AACF;AACDF,aAASA,OAAOY,MAAP,CAAc;AAAA,aAAKF,MAAMb,WAAX;AAAA,KAAd,CAAT;AACAG,WAAOa,IAAP;AACAb,WAAOG,KAAP,CAAa,EAAb,EAAiB,GAAjB;AACA,QAAMW,OAAQd,OAAOE,MAAP,GAAgBH,OAAjB,GAA4B,CAAzC;AACA,QAAMgB,SAAS,EAAf;AACA,SAAK,IAAIL,KAAI,CAAb,EAAgBA,KAAIX,UAAU,CAA9B,EAAiCW,IAAjC,EAAsC;AACpCK,aAAOC,IAAP,CAAYhB,OAAOc,QAAQJ,KAAI,CAAZ,CAAP,CAAZ;AACD;AACD;AACAK,WAAOC,IAAP,CAAYlB,KAAKmB,GAAjB;AACA,WAAOF,MAAP;AACD,GAxBgB;AAAA,CAAjB;;kBA0BenB,Q","file":"quantile.js","sourcesContent":["import { constructor as XorShift } from 'xorshift'\n\n/** A quantile classifier. Pass in an optional no data value */\nconst quantile = ({ noDataValue = null }) => (grid, nBreaks) => {\n  let sample\n  // Use a sample to make the algorithm tractable. Thanks to the central limit theorem this should\n  // be fine.\n  if (grid.data.length < 10000) {\n    sample = grid.data.slice(0)\n  } else {\n    sample = new Int32Array(10000)\n    const generator = new XorShift([grid.west, grid.north, grid.width, grid.height])\n    for (let i = 0; i < 10000; i++) {\n      sample[i] = grid.data[(generator.random() * grid.data.length) | 0]\n    }\n  }\n  sample = sample.filter(i => i !== noDataValue)\n  sample.sort()\n  sample.slice(50, 950)\n  const step = (sample.length / nBreaks) | 0\n  const breaks = []\n  for (let i = 0; i < nBreaks - 1; i++) {\n    breaks.push(sample[step * (i + 1)])\n  }\n  // make sure we don't cut any off at the top\n  breaks.push(grid.max)\n  return breaks\n}\n\nexport default quantile\n"]}