{"version":3,"sources":["equal-interval.js"],"names":["equal","scale","grid","nBreaks","localScale","domain","min","max","range","map","invert","b"],"mappings":";;;;;;AAAA;;AACA;;;;;;AAEA;;;;;;;;;;AAUA,IAAMA,QAAQ,SAARA,KAAQ;AAAA,iFAAa,EAAb;AAAA,MAAGC,KAAH,QAAGA,KAAH;;AAAA,SAAoB,UAACC,IAAD,EAAOC,OAAP,EAAmB;AACnD;AACA,QAAIC,aAAaH,KAAjB;AACA,QAAIG,cAAc,IAAlB,EAAwB;AACtBA,mBAAa,4BACVC,MADU,CACH,CAACH,KAAKI,GAAN,EAAWJ,KAAKK,GAAhB,CADG,CAAb;AAED;;AAED;AACAH,eAAWI,KAAX,CAAiB,CAAC,CAAD,EAAIL,OAAJ,CAAjB;AACA,WAAO,qBAAM,CAAN,EAASA,UAAU,CAAnB,EAAsBM,GAAtB,CAA0B;AAAA,aAAKL,WAAWM,MAAX,CAAkBC,CAAlB,CAAL;AAAA,KAA1B,CAAP;AACD,GAXa;AAAA,CAAd;;kBAaeX,K","file":"equal-interval.js","sourcesContent":["import {scaleLinear} from 'd3-scale'\nimport range from 'lodash/range'\n\n/**\n * equal interval classifier, potentially in a space other than the linear\n * Passing in no arguments will use a linear space. you can also pass in\n * a { scale } parameter, which should be a d3 continuous scale with the domain set correctly.\n *\n * The 'interface' of a classifier is (grid, nBreaks) to an array of break points.\n * We don't want to pass the scale into the classifier itself (only when constructing the classifier) because\n * applying a scale to other classifier types (e.g. quantile) has no effect. We also don't want to completely\n * transform the input data, just temporarily apply the scale while choosing the break points.\n */\nconst equal = ({ scale } = {}) => (grid, nBreaks) => {\n  // copy reference so that it does not persist between calls to thunk\n  let localScale = scale\n  if (localScale == null) {\n    localScale = scaleLinear()\n      .domain([grid.min, grid.max])\n  }\n\n  // we set the range to determine the classes, and then we invert the scale to find where the breakpoints are\n  localScale.range([0, nBreaks])\n  return range(1, nBreaks + 1).map(b => localScale.invert(b))\n}\n\nexport default equal\n"]}