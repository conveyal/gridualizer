{"version":3,"sources":["dot.js"],"names":["Dot","grid","color","rgbArray","canvas","mercTileCoord","zoom","ctx","getContext","imageData","createImageData","width","height","red","green","blue","mercPixelX","x","mercPixelY","y","zoomDifference","gridCellWidthInTilePixels","Math","pow","tileWidthInGridCells","tilePixelsPerGridCell","max","gxMin","west","gyMin","north","gxMax","gyMax","gx","gy","upperLeft","getGridValue","upperRight","lowerLeft","lowerRight","leftSlope","rightSlope","txMin","tyMin","txMax","tyMax","ty","left","right","rowSlope","tx","interpolatedDensity","r","random","opacity","imgOffset","data","set","putImageData","Canvas"],"mappings":"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","file":"dot.js","sourcesContent":["/**\n * Dot density grid, with bilinear interpolation between opportunity density cells and multiple opacity layers\n * for overlappig dots.\n */\n\nimport {TileLayer} from 'leaflet'\nimport Color from 'color'\n\nexport default class Dot extends TileLayer.Canvas {\n  // grid is the grid of opportunity densities to visualize as map tiles (class from Browsochrones).\n  // color is the color of the dots to draw.\n  initialize (grid, color = '#49a0d7') {\n    this.color = new Color(color).rgbArray()\n    this.grid = grid\n  }\n\n  // Given a web Mercator x, y, and zoom values for a single tile, as well as an associated canvas object,\n  // visualize the opportunities falling within that tile as dots on the canvas.\n  drawTile (canvas, mercTileCoord, zoom) {\n    const ctx = canvas.getContext('2d')\n    const imageData = ctx.createImageData(canvas.width, canvas.height)\n\n    const [red, green, blue] = this.color\n\n    // Convert web Mercator tile position to pixels relative to the left and the top of the world at its zoom level.\n    const mercPixelX = mercTileCoord.x * 256\n    const mercPixelY = mercTileCoord.y * 256\n\n    // Compute the divisor that will convert pixel (or tile) coordinates at the visual map tile zoom level\n    // to pixel (or tile) coordinates at the opportunity density grid's zoom level, i.e. the number of visual map\n    // pixels (or tiles) an opportunity grid pixel (or tile) is wide.\n    // This is always a power of two, so as an optimization we could just store the difference in zoom levels\n    // and scale using bitshift operators.\n    const zoomDifference = zoom - this.grid.zoom\n    // FIXME what happens below when zoomDifference is negative, i.e. when we're really zoomed out?\n    const gridCellWidthInTilePixels = Math.pow(2, zoomDifference)\n    const tileWidthInGridCells = 256 / gridCellWidthInTilePixels\n    // The total number of tile pixels falling within one grid cell, i.e. the square of the width in pixels.\n    // This is used to convert job counts per cell to job counts per pixel.\n    // NOTE that this is instead proportional to the number of pixels in one dimension, which seems to scale better\n    // const tilePixelsPerGridCell = gridCellWidthInTilePixels * gridCellWidthInTilePixels * 150\n    // const tilePixelsPerGridCell = ZSCALE_BY_ZOOM[zoom] * 500\n    const tilePixelsPerGridCell = gridCellWidthInTilePixels * this.grid.max / 200\n\n    // Find the range of grid cells that contribute to the contents of the map tile we're rendering.\n    // When interpolating, we consider the grid cell value to be at the center of the cell,\n    // so we need to hit one extra row of cells outside the tile.\n    const gxMin = mercPixelX / gridCellWidthInTilePixels - this.grid.west - 1\n    const gyMin = mercPixelY / gridCellWidthInTilePixels - this.grid.north - 1\n    const gxMax = gxMin + tileWidthInGridCells + 1\n    const gyMax = gyMin + tileWidthInGridCells + 1\n\n    // Iterate over all opportunity grid pixels that contribute to the contents of the map tile we're rendering.\n    // Due to the fact that mercator grid zoom level sizes are powers of two,\n    // when multiple opportunity grid cells fall within a map tile there are always\n    // an integer number of them and no partial overlaps.\n    // But for interpolation purposes, we work on boxes that are offset 1/2 cell to the east and south because\n    // we consider grid cell values to be at the center (rather than the corner) of those cells.\n    for (let gx = gxMin; gx < gxMax; gx++) {\n      for (let gy = gyMin; gy < gyMax; gy++) {\n        // Get density at the four corners of a box extending one cell east and south of the current cell.\n        // These densities are adjusted for the number of pixels in a cell, so they represent the average number of\n        // opportunities in a single pixel.\n        const upperLeft = this.getGridValue(gx, gy) / tilePixelsPerGridCell\n        const upperRight = this.getGridValue(gx + 1, gy) / tilePixelsPerGridCell\n        const lowerLeft = this.getGridValue(gx, gy + 1) / tilePixelsPerGridCell\n        const lowerRight = this.getGridValue(gx + 1, gy + 1) / tilePixelsPerGridCell\n        // Do not bother rendering cell if all corners are zero.\n        if (upperLeft === 0 && upperRight === 0 && lowerLeft === 0 && lowerRight === 0) continue\n        // Determine slopes. Linear interpolation along the left and right edges of the box.\n        const leftSlope = (lowerLeft - upperLeft) / gridCellWidthInTilePixels\n        const rightSlope = (lowerRight - upperRight) / gridCellWidthInTilePixels\n        // Iterate over all tile pixels falling within this box\n        // Note the half-grid-cell offset because the grid cell value is considered to be at the cell's center.\n        const txMin = (gx - gxMin) * gridCellWidthInTilePixels - gridCellWidthInTilePixels / 2\n        const tyMin = (gy - gyMin) * gridCellWidthInTilePixels - gridCellWidthInTilePixels / 2\n        const txMax = txMin + gridCellWidthInTilePixels\n        const tyMax = tyMin + gridCellWidthInTilePixels\n        for (let ty = tyMin; ty < tyMax; ty++) {\n          if (ty < 0 || ty > 255) continue\n          // Evaluate the interpolated lines on the left and right edges of the box at this row of pixels.\n          // Then interpolate again along the other axis from left to right (bilinear interpolation).\n          const left = upperLeft + leftSlope * (ty - tyMin)\n          const right = upperRight + rightSlope * (ty - tyMin)\n          const rowSlope = (right - left) / gridCellWidthInTilePixels\n          for (let tx = txMin; tx < txMax; tx++) {\n            if (tx < 0 || tx > 255) continue\n            const interpolatedDensity = left + rowSlope * (tx - txMin)\n            // Get a random number in [0, 1)\n            // and plot a dot if that number is less than the number of things in this pixel.\n            // We were using a JS Mersenne Twister, which was using 65% of CPU time according to a profiler.\n            // Math.random uses an xorshift method in V8, dropping to 4% of CPU time.\n            const r = Math.random()\n            if (r < interpolatedDensity) {\n              let opacity = 64\n              if (r * 2 < interpolatedDensity) opacity += 64\n              if (r * 3 < interpolatedDensity) opacity += 64\n              if (r * 4 < interpolatedDensity) opacity += 63\n              const imgOffset = (ty * 256 + tx) * 4\n              imageData.data.set([red, green, blue, opacity], imgOffset)\n            }\n          }\n        }\n      }\n    }\n    ctx.putImageData(imageData, 0, 0)\n  }\n\n  // Return the value of an opportunity density grid cell.\n  // Range check and return 0 for cells outside the grid.\n  getGridValue (gx, gy) {\n    if (gx < 0 || gx >= this.grid.width || gy < 0 || gy >= this.grid.height) return 0\n    // Convert grid x and y cell coordinates to a 1D offset into the grid\n    return this.grid.data[gy * this.grid.width + gx]\n  }\n}\n"]}