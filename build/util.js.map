{"version":3,"sources":["util.js"],"names":["getGridValue","normalizeColors","getGridPercentiles","getTrimmedMax","getTrimmedMax2","getTrimmedMax3","drawDot","grid","gx","gy","width","height","data","colors","map","Array","isArray","c","length","push","rgb","r","g","b","opacity","Math","floor","MAX_SIZE","noDataValue","cleanedData","filter","i","sample","Int32Array","generator","west","north","random","sort","step","percentiles","p","distinct","from","maxes","max","s","x","medianMax","MIN_DENSITY","imgData","y","color","dy","dx","imgOffset","set"],"mappings":";;;;;;;;;;QAagBA,Y,GAAAA,Y;QAYAC,e,GAAAA,e;QAoBAC,kB,GAAAA,kB;QAyBAC,a,GAAAA,a;QAQAC,c,GAAAA,c;QAqBAC,c,GAAAA,c;QAeAC,O,GAAAA,O;;AAlHhB;;AACA;;;;AAEA;;;;AAIA;;;;;;AAMO,SAASN,YAAT,CAAuBO,IAAvB,EAA6BC,EAA7B,EAAiCC,EAAjC,EAAqC;AAC1C,MAAID,KAAK,CAAL,IAAUA,MAAMD,KAAKG,KAArB,IAA8BD,KAAK,CAAnC,IAAwCA,MAAMF,KAAKI,MAAvD,EAA+D,OAAO,CAAP;AAC/D;AACA;AACA,SAAOJ,KAAKK,IAAL,CAAUH,KAAKF,KAAKG,KAAV,GAAkBF,EAA5B,CAAP;AACD;;AAED;;;;;AAKO,SAASP,eAAT,CAA0BY,MAA1B,EAAkC;AACvC,SAAOA,OAAOC,GAAP,CAAW,aAAK;AACrB,QAAIC,MAAMC,OAAN,CAAcC,CAAd,CAAJ,EAAsB;AACpB;AACA,UAAIA,EAAEC,MAAF,KAAa,CAAjB,EAAoBD,EAAEE,IAAF,CAAO,GAAP;AACrB,KAHD,MAGO;AACL;AACAF,UAAI,oBAAWA,CAAX,EAAcG,GAAd,EAAJ;AACAH,UAAI,CAACA,EAAEI,CAAH,EAAMJ,EAAEK,CAAR,EAAWL,EAAEM,CAAb,EAAgBN,EAAEO,OAAlB,CAAJ;AACD;AACD;AACA;AACA,QAAIP,EAAE,CAAF,IAAO,CAAX,EAAcA,EAAE,CAAF,IAAOQ,KAAKC,KAAL,CAAWT,EAAE,CAAF,KAAQ,GAAnB,CAAP;AACd,WAAOA,CAAP;AACD,GAbM,CAAP;AAcD;;AAED;;;AAGO,SAASf,kBAAT,CAA6BK,IAA7B,EAAmC;AACxC,MAAMoB,WAAW,KAAjB,CADwC,CACjB;AACvB,MAAMC,cAAc,IAApB;AACA,MAAIC,cAActB,KAAKK,IAAL,CAAUkB,MAAV,CAAiB;AAAA,WAAKC,IAAI,CAAJ,IAASA,MAAMH,WAApB;AAAA,GAAjB,CAAlB;AACA,MAAIC,YAAYX,MAAZ,GAAqBS,QAAzB,EAAmC;AACjC,QAAMK,SAAS,IAAIC,UAAJ,CAAeN,QAAf,CAAf;AACA;AACA,QAAMO,YAAY,0BAAa,CAAC3B,KAAK4B,IAAN,EAAY5B,KAAK6B,KAAjB,EAAwB7B,KAAKG,KAA7B,EAAoCH,KAAKI,MAAzC,CAAb,CAAlB;AACA,SAAK,IAAIoB,IAAI,CAAb,EAAgBA,IAAIJ,QAApB,EAA8BI,GAA9B,EAAmC;AACjCC,aAAOD,CAAP,IAAYF,YAAaK,UAAUG,MAAV,KAAqBR,YAAYX,MAAlC,GAA4C,CAAxD,CAAZ;AACD;AACDW,kBAAcG,MAAd;AACD;AACDH,cAAYS,IAAZ;AACA,MAAMC,OAAOV,YAAYX,MAAZ,GAAqB,KAAlC;AACA,MAAMsB,cAAc,EAApB;AACA,OAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAI,GAApB,EAAyBA,GAAzB,EAA8B;AAC5BD,gBAAYC,CAAZ,IAAiBZ,YAAaU,OAAOE,CAAR,GAAa,CAAzB,CAAjB;AACD;AACD,SAAOD,WAAP;AACD;;AAED;AACA;AACA;AACO,SAASrC,aAAT,CAAwBI,IAAxB,EAA8B;AACnC,MAAMmC,WAAWT,WAAWU,IAAX,CAAgB,kBAAQpC,KAAKK,IAAb,CAAhB,CAAjB;AACA8B,WAASJ,IAAT;AACA,SAAOI,SAAUA,SAASxB,MAAT,GAAkB,IAAnB,GAA2B,CAApC,CAAP;AACD;;AAED;AACA;AACO,SAASd,cAAT,CAAyBG,IAAzB,EAA+B;AACpC,MAAMqB,cAAc,IAApB;AACA,MAAMC,cAActB,KAAKK,IAAL,CAAUkB,MAAV,CAAiB;AAAA,WAAKC,IAAI,CAAJ,IAASA,MAAMH,WAApB;AAAA,GAAjB,CAApB;AACAC,cAAYS,IAAZ;AACA,MAAMJ,YAAY,0BAAa,CAAC3B,KAAK4B,IAAN,EAAY5B,KAAK6B,KAAjB,EAAwB7B,KAAKG,KAA7B,EAAoCH,KAAKI,MAAzC,CAAb,CAAlB;AACA,MAAMiC,QAAQ,EAAd;AACA,OAAK,IAAIb,IAAI,CAAb,EAAgBA,IAAI,EAApB,EAAwBA,GAAxB,EAA6B;AAC3B,QAAIc,MAAM,CAAV;AACA,SAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAI,KAApB,EAA2BA,GAA3B,EAAgC;AAC9B,UAAMC,IAAIlB,YAAaK,UAAUG,MAAV,KAAqBR,YAAYX,MAAlC,GAA4C,CAAxD,CAAV;AACA,UAAI6B,IAAIF,GAAR,EAAaA,MAAME,CAAN;AACd;AACDH,UAAMzB,IAAN,CAAW0B,GAAX;AACD;AACDD,QAAMN,IAAN;AACA,MAAMU,YAAYJ,MAAOA,MAAM1B,MAAN,GAAe,CAAhB,GAAqB,CAA3B,CAAlB;AACA,SAAO8B,SAAP;AACD;;AAED;AACA;AACO,SAAS3C,cAAT,CAAyBE,IAAzB,EAA+B;AACpC,MAAM0C,cAAc,EAApB;AACA,MAAMrB,cAAc,IAApB;AACA,MAAMC,cAActB,KAAKK,IAAL,CAAUkB,MAAV,CAAiB;AAAA,WAAKC,IAAIkB,WAAJ,IAAmBlB,MAAMH,WAA9B;AAAA,GAAjB,CAApB;AACAC,cAAYS,IAAZ;AACA,SAAOT,YAAaA,YAAYX,MAAZ,GAAqB,IAAtB,GAA8B,CAA1C,CAAP;AACD;;AAED;;;;;;;AAOO,SAASZ,OAAT,CAAkB4C,OAAlB,EAA2BH,CAA3B,EAA8BI,CAA9B,EAAiCzC,KAAjC,EAAwC0C,KAAxC,EAA+C;AACpD;AACA,OAAK,IAAIC,KAAK,CAAd,EAAiBA,KAAK3C,KAAtB,EAA6B2C,IAA7B,EAAmC;AACjC,QAAIF,IAAIE,EAAJ,GAAS,GAAb,EAAkB;AAClB,SAAK,IAAIC,KAAK,CAAd,EAAiBA,KAAK5C,KAAtB,EAA6B4C,IAA7B,EAAmC;AACjC,UAAIP,IAAIO,EAAJ,GAAS,GAAb,EAAkB;AAClB,UAAMC,YAAY,CAAC,CAACJ,IAAIE,EAAL,IAAW,GAAX,GAAiBN,CAAjB,GAAqBO,EAAtB,IAA4B,CAA9C;AACAJ,cAAQtC,IAAR,CAAa4C,GAAb,CAAiBJ,KAAjB,EAAwBG,SAAxB;AACD;AACF;AACF","file":"util.js","sourcesContent":["import {color as parseColor} from 'd3-color'\nimport {constructor as XorShift} from 'xorshift'\n\n/**\n * This module contains library functions reused throughout the project.\n */\n\n/**\n * Return the value of an opportunity density grid cell.\n * Range check and return 0 for cells outside the grid.\n * TODO This should really be in the Grid class, and grids should have a default value for empty cells.\n * Alternatively, we could inject this into the grid object itself but that might be bad form.\n */\nexport function getGridValue (grid, gx, gy) {\n  if (gx < 0 || gx >= grid.width || gy < 0 || gy >= grid.height) return 0\n  // Convert grid x and y cell coordinates to a 1D offset into the grid.\n  // This is a good place to apply log or sqrt transformations if needed.\n  return grid.data[gy * grid.width + gx]\n}\n\n/**\n * Convert an array of colors where each color is a D3 color string, an [r, g, b] array, or an [r, g, b, a] array\n * fractional or integer alpha to an array of [r, g, b, a] arrays with integer alpha,\n * which is what we write directly into output pixels.\n */\nexport function normalizeColors (colors) {\n  return colors.map(c => {\n    if (Array.isArray(c)) {\n      // Add alpha if it's missing\n      if (c.length === 3) c.push(255)\n    } else {\n      // Color is not an array, treat it as a D3 color specification\n      c = parseColor(c).rgb()\n      c = [c.r, c.g, c.b, c.opacity]\n    }\n    // At this point, c should always be an array of four numbers.\n    // Convert floating point alpha to in integer if needed.\n    if (c[3] < 1) c[3] = Math.floor(c[3] *= 255)\n    return c\n  })\n}\n\n/**\n * Given a Grid, return an array of 100 quantiles of the non-zero, non-missing values in that Grid.\n */\nexport function getGridPercentiles (grid) {\n  const MAX_SIZE = 10000 // Actually this runs pretty fast even with 160k elements\n  const noDataValue = null\n  let cleanedData = grid.data.filter(i => i > 0 && i !== noDataValue)\n  if (cleanedData.length > MAX_SIZE) {\n    const sample = new Int32Array(MAX_SIZE)\n    // Initialize the random number generator with the grid's characteristics to make results reproducible\n    const generator = new XorShift([grid.west, grid.north, grid.width, grid.height])\n    for (let i = 0; i < MAX_SIZE; i++) {\n      sample[i] = cleanedData[(generator.random() * cleanedData.length) | 0]\n    }\n    cleanedData = sample\n  }\n  cleanedData.sort()\n  const step = cleanedData.length / 100.0\n  const percentiles = []\n  for (let p = 0; p < 101; p++) {\n    percentiles[p] = cleanedData[(step * p) | 0]\n  }\n  return percentiles\n}\n\n// Get the 99th percentile of all the _unique_ values in the grid.\n// There are a huge amouunt of zeros, ones, twos etc. so most approaches using percentiles to transform the data\n// remap all of the interesting data up near 1.0, creating an almost solid-filled plot.\nexport function getTrimmedMax (grid) {\n  const distinct = Int32Array.from(new Set(grid.data))\n  distinct.sort()\n  return distinct[(distinct.length * 0.99) | 0]\n}\n\n// Attempt to remove outliers by repeatedly finding the maximum of random samples of the data.\n// The typical 1.5x interquartile range approach is not effective because density is not normally distributed.\nexport function getTrimmedMax2 (grid) {\n  const noDataValue = null\n  const cleanedData = grid.data.filter(i => i > 0 && i !== noDataValue)\n  cleanedData.sort()\n  const generator = new XorShift([grid.west, grid.north, grid.width, grid.height])\n  const maxes = []\n  for (let i = 0; i < 15; i++) {\n    let max = 0\n    for (let s = 0; s < 10000; s++) {\n      const x = cleanedData[(generator.random() * cleanedData.length) | 0]\n      if (x > max) max = x\n    }\n    maxes.push(max)\n  }\n  maxes.sort()\n  const medianMax = maxes[(maxes.length / 2) | 0]\n  return medianMax\n}\n\n// Find the 99th percentile of all the grid data not near zero.\n// Requires magic numbers (minimum density) to get good results where there are lots of small-valued cells.\nexport function getTrimmedMax3 (grid) {\n  const MIN_DENSITY = 50\n  const noDataValue = null\n  const cleanedData = grid.data.filter(i => i > MIN_DENSITY && i !== noDataValue)\n  cleanedData.sort()\n  return cleanedData[(cleanedData.length * 0.99) | 0]\n}\n\n/**\n * This will draw one dot into the imageData, as a square with the given width.\n * If you set width to a number that increases by powers of 2 with the zoom level, this gives the illusion of\n * dots of a fixed geographic size. For example, width = (zoom - 12) ** 2.\n * The problem is that at least with our current method these dots jump around when you zoom (random placement)\n * and the dots are rendered to a single tile in isolation, so dots are clipped at the edge of tiles.\n */\nexport function drawDot (imgData, x, y, width, color) {\n  // Resulting color has some opacity, write it into the tile\n  for (let dy = 0; dy < width; dy++) {\n    if (y + dy > 255) break\n    for (let dx = 0; dx < width; dx++) {\n      if (x + dx > 255) continue\n      const imgOffset = ((y + dy) * 256 + x + dx) * 4\n      imgData.data.set(color, imgOffset)\n    }\n  }\n}\n"]}