{"version":3,"sources":["dither.js"],"names":["DitherColorizer","breaks","colors","baseColorizer","value","rand","gaussianApproximation","iterations","width","mean","sum","i","Math","random"],"mappings":";;;;;;AAAA;;;;;;AAEA;;;;;;;;;;AAUA,IAAMA,kBAAkB,SAAlBA,eAAkB,CAACC,MAAD,EAASC,MAAT,EAAoB;AAC1C,MAAMC,gBAAgB,0BAAoBF,MAApB,EAA4BC,MAA5B,CAAtB;AACA,SAAO,UAACE,KAAD,EAAW;AAChB,QAAMC,OAAOC,sBAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,CAAb;AACA,WAAOH,cAAcE,OAAOD,KAArB,CAAP;AACD,GAHD;AAID,CAND;;AAQA;;;;AAIA,IAAME,wBAAwB,SAAxBA,qBAAwB,CAACC,UAAD,EAAaC,KAAb,EAAoBC,IAApB,EAA6B;AACzD,MAAIC,MAAM,CAAV;AACA,OAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIJ,UAApB,EAAgCI,GAAhC;AAAqCD,WAAOE,KAAKC,MAAL,EAAP;AAArC,GAFyD,CAGzD;AACA,SAAO,CAAEH,MAAMH,UAAP,GAAqB,GAAtB,IAA6BC,KAA7B,GAAqCC,IAA5C;AACD,CALD;;kBAOeT,e","file":"dither.js","sourcesContent":["import ChoroplethColorizer from './choropleth'\n\n/**\n * Each pixel is set to the color for a number between 0 and 2x 'value', with expected value 'value'.\n * The idea is that the underlying grid is supplying a human/opportunity density number at every pixel.\n * There may be more or less people than that average density in a given pixel, but across a whole area of equal density\n * the average should be roughly correct.\n * In low density places, the choropleth should step up in opacity for each person present in a pixel.\n * The breaks would just be 0, 1, 2. However, density ranges can be very wide, so we generalize the idea to\n * arbitrary, possibly nonlinear breaks. We also don't want the perceived color to 'dilute' severely as we zoom in,\n * so we do not adjust the densities for the number of pixels per cell.\n */\nconst DitherColorizer = (breaks, colors) => {\n  const baseColorizer = ChoroplethColorizer(breaks, colors)\n  return (value) => {\n    const rand = gaussianApproximation(2, 2, 1)\n    return baseColorizer(rand * value)\n  }\n}\n\n/**\n * Approximate a normal distribution with a Bates distribution (the mean of N uniform random variables on [0, 1]).\n * The function returns a single draw from such an approximation centered on the given mean, with the given width.\n */\nconst gaussianApproximation = (iterations, width, mean) => {\n  let sum = 0\n  for (let i = 0; i < iterations; i++) sum += Math.random()\n  // Center around zero and expand to specified width\n  return ((sum / iterations) - 0.5) * width + mean\n}\n\nexport default DitherColorizer\n"]}