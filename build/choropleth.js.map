{"version":3,"sources":["choropleth.js"],"names":["getClassIndex","Choropleth","grid","breaks","equal","colors","labels","Array","length","map","c","canvas","zoom","x","y","ctx","getContext","imageData","createImageData","width","height","zoomFactor","Math","pow","ty","offset","tx","mx","my","gx","west","gy","north","withinGrid","value","data","classIdx","undefined","console","log","set","rgbArray","putImageData","fromGridX","toGridX","fromGridY","toGridY","font","fillStyle","fillText","Canvas","nBreaks","step","max","min","loc","push","quantile","noDataValue","sample","slice","Int32Array","generator","i","random","filter","sort","equalDiverging","breaksPerSide","quantileDiverging","dataBelow","dataAbove","classifier","breaksBelow","breaksAbove"],"mappings":"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","file":"choropleth.js","sourcesContent":["/** A Leaflet layer for showing a grid as a choropleth map */\n\nimport {TileLayer} from 'leaflet'\nimport Color from 'color'\nimport range from 'lodash.range'\nimport { constructor as XorShift } from 'xorshift'\n\nexport default class Choropleth extends TileLayer.Canvas {\n  /** Construct with a browsochrones grid object */\n  // colors courtesy http://colorbrewer2.org/\n  initialize (grid, breaks = Choropleth.equal(), colors = ['#eff3ff', '#bdd7e7', '#6baed6', '#3182bd', '#08519c'], labels = 100) {\n    this.grid = grid\n\n    this.labels = labels\n\n    // equal interval\n    if (breaks instanceof Array) {\n      this.breaks = breaks\n    } else {\n      this.breaks = breaks(grid, colors.length)\n    }\n\n    this.colors = colors.map(c => new Color(c))\n  }\n\n  drawTile (canvas, { x, y }, zoom) {\n    const ctx = canvas.getContext('2d')\n    const imageData = ctx.createImageData(canvas.width, canvas.height)\n\n    // convert to pixels\n    x *= 256\n    y *= 256\n\n    // factor to convert to zoom of grid\n    const zoomFactor = Math.pow(2, zoom - this.grid.zoom)\n\n    for (let ty = 0, offset = 0; ty < canvas.height; ty++) {\n      for (let tx = 0; tx < canvas.width; tx++, offset += 4) {\n        // convert tile coords to web mercator pixels\n        let mx = x + tx / canvas.width * 256\n        let my = y + ty / canvas.height * 256\n\n        // convert zoom level\n        mx /= zoomFactor\n        my /= zoomFactor\n\n        // whole pixel values only, floor\n        mx |= 0\n        my |= 0\n\n        // get grid coords\n        const gx = mx - this.grid.west\n        const gy = my - this.grid.north\n\n        const withinGrid = !(gx < 0 || gx >= this.grid.width || gy < 0 || gy >= this.grid.height)\n        const value = withinGrid ? this.grid.data[gy * this.grid.width + gx] : 0\n\n        const classIdx = getClassIndex(value, this.breaks)\n\n        if (this.colors[classIdx] === undefined) {\n          console.log('undefined')\n        }\n\n        imageData.data.set([...this.colors[classIdx].rgbArray(), 50], offset)\n      }\n    }\n\n    ctx.putImageData(imageData, 0, 0)\n\n    // draw labels if zoom level is high enough\n    if (zoom > this.labels) {\n      // find contained pixels\n      const fromGridX = x / zoomFactor - this.grid.west\n      const toGridX = (x + 256) / zoomFactor - this.grid.west\n      const fromGridY = y / zoomFactor - this.grid.north\n      const toGridY = (y + 256) / zoomFactor - this.grid.north\n\n      // if we're zoomed in really far and a single grid pixel takes up multiple map tiles, don't\n      // label tiles that are not the top-left-most. Since the mercator pixels nest, some tile will\n      // line up with the edge of each grid pixel\n      if (fromGridX % 1 === 0 && fromGridY % 1 === 0) {\n        for (let gx = fromGridX; gx < toGridX; gx++) {\n          if (gx < 0 || gx >= this.grid.width) continue\n          const tx = ((gx + this.grid.west) * zoomFactor - x) / 256 * canvas.width\n\n          for (let gy = fromGridY; gy < toGridY; gy++) {\n            if (gy < 0 || gy >= this.grid.height) continue\n            const ty = ((gy + this.grid.north) * zoomFactor - y) / 256 * canvas.height\n\n            ctx.font = '10px sans'\n            ctx.fillStyle = 'black'\n            ctx.fillText(`${this.grid.data[gy * this.grid.width + gx]}\\n(${gx}, ${gy})`, tx, ty + 10)\n          }\n        }\n      }\n    }\n  }\n\n /** equal interval classifier */\n  static equal = () => (grid, nBreaks) => {\n    let breaks = []\n    let step = (grid.max - grid.min) / nBreaks\n    for (let loc = grid.min + step; loc <= grid.max; loc += step) {\n      breaks.push(loc)\n    }\n\n    return breaks\n  }\n\n  /** Quantile classifier */\n  static quantile = ({ noDataValue = null }) => (grid, nBreaks) => {\n    let sample\n\n    // Use a sample to make the algorithm tractable. Thanks to the central limit theorem this should\n    // be fine.\n    if (grid.data.length < 10000) {\n      sample = grid.data.slice(0)\n    } else {\n      sample = new Int32Array(10000)\n      const generator = new XorShift([grid.west, grid.north, grid.width, grid.height])\n\n      for (let i = 0; i < 10000; i++) {\n        sample[i] = grid.data[(generator.random() * grid.data.length) | 0]\n      }\n    }\n\n    sample = sample.filter(i => i !== noDataValue)\n    sample.sort()\n\n    let step = (sample.length / nBreaks) | 0\n\n    let breaks = []\n\n    for (let i = 0; i < nBreaks - 1; i++) {\n      breaks.push(sample[step * (i + 1)])\n    }\n\n    // make sure we don't cut any off at the top\n    breaks.push(grid.max)\n\n    return breaks\n  }\n\n  /** Equal interval for diverging data, forces middle class to contain zero */\n  static equalDiverging = () => (grid, nBreaks) => {\n    if (nBreaks % 2 === 0) nBreaks-- // we need an odd number of clases, subtract so we don't run off the end of the color scale\n\n    const breaksPerSide = (nBreaks + 1) / 2\n\n    const breaks = []\n\n    // make the breaks below zero\n    let step = (0 - grid.min) / breaksPerSide\n\n    if (step <= 0) {\n      // -1 because we don't include the top break from the lower half (the middle class is the\n      // merger of the top class from the lower half and the bottom class from the upper)\n      for (let i = 0; i < breaksPerSide - 1; i++) breaks.push(0)\n    } else {\n      for (let loc = grid.min + step; loc < 0; loc += step) {\n        breaks.push(loc)\n      }\n    }\n\n    step = grid.max / breaksPerSide\n\n    if (step <= 0) {\n      for (let i = 0; i < breaksPerSide; i++) breaks.push(0)\n    } else {\n      for (let loc = step; loc < grid.max; loc += step) {\n        breaks.push(loc)\n      }\n    }\n\n    return breaks\n  }\n\n  static quantileDiverging = ({ noDataValue }) => (grid, nBreaks) => {\n    if (nBreaks % 2 === 0) nBreaks-- // we need an odd number of clases\n\n    const breaksPerSide = (nBreaks + 1) / 2\n\n    const dataBelow = grid.data.filter(i => i < 0)\n    const dataAbove = grid.data.filter(i => i > 0)\n\n    const classifier = Choropleth.quantile({noDataValue})\n    const breaksBelow = dataBelow.length > 0\n      ? classifier({ ...grid, data: dataBelow }, breaksPerSide).slice(0, breaksPerSide - 1)\n      : range(breaksPerSide - 1).map(i => 0)\n    const breaksAbove = dataAbove.length > 0\n      ? classifier({ ...grid, data: dataAbove }, breaksPerSide)\n      : range(breaksPerSide).map(i => 0)\n\n    return [...breaksBelow, ...breaksAbove]\n  }\n}\n\n/**\n * Get the class index based on breaks (breaks[i] is the top of class i).\n * Separate function so that unit tests can be written.\n */\nexport function getClassIndex (value, breaks) {\n  // increment the class index until we get to the end of the array or the previous break is smaller\n  // than the value\n  let classIdx = 0\n  while (classIdx < breaks.length - 1 && breaks[classIdx] < value) classIdx++\n  return classIdx\n}\n"]}