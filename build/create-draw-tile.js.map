{"version":3,"sources":["create-draw-tile.js"],"names":["createDrawTile","colorizer","grid","interpolator","trimmedMax","normalize","drawTile","canvas","mercTileCoord","zoom","canvasContext","getContext","imageData","createImageData","width","height","mercPixelX","x","mercPixelY","y","zoomDifference","gridCellWidthInTilePixels","tileWidthInGridCells","tilePixelsPerGridCell","dilutionFactor","finalInterpolator","gridOffset","gxMin","Math","floor","west","gyMin","north","gxMax","ceil","gyMax","gridStep","gx","gy","patch","txMin","tyMin","txMax","tyMax","ty","row","tx","interpolatedValue","color","imgOffset","data","set","putImageData"],"mappings":"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","file":"create-draw-tile.js","sourcesContent":["// @flow\nimport nearest from './interpolators/nearest'\nimport {getTrimmedMax} from './util'\n\nexport default function createDrawTile ({colorizer, grid, interpolator}: {\n  colorizer(number): number[],\n  grid: Object,\n  interpolator(Object, number, number): (number) => (number) => number\n}) {\n  // Find a maximum with outliers trimmed off only when needed, because it can take some time.\n  const trimmedMax = colorizer.normalize === true ? getTrimmedMax(grid) : 0\n\n  /**\n   * Given a web Mercator x, y, and zoom values for a single tile, as well as an associated canvas object,\n   * visualize the grid cell counts falling within that tile as colors or dots on the canvas.\n   */\n  function drawTile (canvas: HTMLCanvasElement, mercTileCoord: {x: number, y: number}, zoom: number) {\n    const canvasContext = canvas.getContext('2d')\n    if (!canvasContext) return\n\n    const imageData = canvasContext.createImageData(canvas.width, canvas.height)\n\n    // Convert web Mercator tile position to pixels relative to the left and the top of the world at its zoom level.\n    const mercPixelX = mercTileCoord.x * 256\n    const mercPixelY = mercTileCoord.y * 256\n\n    // Compute the divisor that will convert pixel (or tile) coordinates at the visual map tile zoom level\n    // to pixel (or tile) coordinates at the opportunity density grid's zoom level, i.e. the number of visual map\n    // pixels (or tiles) an opportunity grid pixel (or tile) is wide. This is always a power of two,\n    // so as an optimization we could just store the difference in zoom levels and scale using bitshift operators.\n    // When zoomDifference is non-positive (when we're really zoomed out) tileWidthInGridCells will be > 256 and\n    // gridCellWidthInTilePixels will be in (0..1).\n    const zoomDifference = zoom - grid.zoom\n    const gridCellWidthInTilePixels = 2 ** zoomDifference\n    const tileWidthInGridCells = 256 / gridCellWidthInTilePixels\n    const tilePixelsPerGridCell = gridCellWidthInTilePixels ** 2\n\n    // The dot colorizer requires its input to be normalized to the range [0..1] and saturates at 1.\n    // We don't show one dot per opportunity, we want to show one dot per N opportunities such that the probability\n    // of a dot appearing at our trimmedMax value is 1. This simply means dividing the values by the trimmedMax.\n    // However, as we zoom in these probabilities that are passed to the dot colorizer remain the same, probabilities\n    // in the range [0..1] but an increasing number of pixels that may be switched on or off fall within each grid cell.\n    // So as we zoom in and the resolution increases, each dot represents a smaller and smaller number of opportunities.\n    // At some zoom level, dependent on the trimmedMax we are normalizing to, a dot will represent less than one\n    // opportunity. This is undesirable because it can give the impression that some category of opportunities is very\n    // prevalent on the map when in fact it's just uniformly scarce.\n    // We want to hold the divisor (\"dilutionFactor\") constant at trimmedMax to create the visual impression that as\n    // we zoom in, dot density remains constant over a given geographic area. What we are effectively doing is\n    // dividing the raw interpolated density by the number of opportunities per dot, then by the number\n    // of pixels within a grid cell at the current zoom level to spread the probability over many pixels.\n    //   density / dilutionFactor\n    // = density / opportunitiesPerDot / tilePixelsPerGridCell\n    // = density / (opportunitiesPerDot * tilePixelsPerGridCell)\n    // dilutionFactor = opportunitiesPerDot * tilePixelsPerGridCell\n    // opportunitiesPerDot = dilutionFactor / tilePixelsPerGridCell ; opportunitiesPerDot >= 1\n    // dilutionFactor / tilePixelsPerGridCell >= 1\n    // dilutionFactor >= tilePixelsPerGridCell\n    let dilutionFactor = trimmedMax\n    // Force implicit opportunitiesPerDot >= 1\n    if (dilutionFactor < tilePixelsPerGridCell) dilutionFactor = tilePixelsPerGridCell\n\n    // Fall back on nearest neighbor when each grid cell covers one or less tile pixels.\n    // Also when each tile covers a fraction of a grid cell.\n    const finalInterpolator = interpolator === null || zoomDifference <= 1 || zoomDifference > 8\n      ? nearest\n      : interpolator\n\n    // Find the range of grid cells that contribute to the contents of the map tile we're rendering.\n    // Most interpolators consider the grid cell value to be at the center of the cell,\n    // so we need to hit one extra row of cells outside the tile.\n    const gridOffset = finalInterpolator.gridOffset\n    const gxMin = Math.floor(mercPixelX / gridCellWidthInTilePixels - grid.west - gridOffset)\n    const gyMin = Math.floor(mercPixelY / gridCellWidthInTilePixels - grid.north - gridOffset)\n    const gxMax = Math.ceil(gxMin + tileWidthInGridCells + gridOffset)\n    const gyMax = Math.ceil(gyMin + tileWidthInGridCells + gridOffset)\n\n    // When zoomed far enough out, we can skip over some grid cells.\n    let gridStep = 1\n    if (zoomDifference < 0) gridStep = 2 ** -zoomDifference\n\n    // Iterate over all opportunity grid pixels that contribute to the contents of the map tile we're rendering.\n    // Due to the fact that mercator grid zoom level sizes are powers of two, when multiple opportunity grid\n    // cells fall within a map tile there are always an integer number of them and no partial overlaps.\n    // But for interpolation purposes, we work on boxes that are offset 1/2 cell to the east and south because\n    // we consider grid cell values to be at the center (rather than the corner) of those cells.\n    // FIXME maybe we should be adding half the gridStep to use the grid cell in the center of the range.\n    for (let gx = gxMin; gx < gxMax; gx += gridStep) {\n      for (let gy = gyMin; gy < gyMax; gy += gridStep) {\n        const patch = finalInterpolator(grid, gx | 0, gy | 0)\n        // Iterate over all the output tile pixels covered by this patch.\n        // These are truncated to integers to handle the case where grid cells are smaller than tile pixels.\n        const txMin = ((gx - gxMin - gridOffset) * gridCellWidthInTilePixels) | 0\n        const tyMin = ((gy - gyMin - gridOffset) * gridCellWidthInTilePixels) | 0\n        const txMax = Math.ceil(txMin + gridCellWidthInTilePixels) | 0\n        const tyMax = Math.ceil(tyMin + gridCellWidthInTilePixels) | 0\n        for (let ty = tyMin; ty < tyMax; ty++) {\n          if (ty < 0 || ty > 255) continue\n          // Todo: refactor to iterate over relative x and y?\n          // Get a single-row 1d interpolator function from the 2d interpolator\n          const row = patch((ty - tyMin) / gridCellWidthInTilePixels)\n          for (let tx = txMin; tx < txMax; tx++) {\n            if (tx < 0 || tx > 255) continue\n            // TODO refactor to iterate over relative x and y?\n            let interpolatedValue = row((tx - txMin) / gridCellWidthInTilePixels)\n            if (colorizer.normalize === true) interpolatedValue /= dilutionFactor\n            const color = colorizer(interpolatedValue)\n            if (color[3] !== 0) {\n              // Resulting color has some opacity, write it into the tile\n              const imgOffset = (ty * 256 + tx) * 4\n              imageData.data.set(color, imgOffset)\n            }\n          }\n        }\n      }\n    }\n    canvasContext.putImageData(imageData, 0, 0)\n  }\n\n  return drawTile\n}\n"]}