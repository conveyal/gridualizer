{"version":3,"sources":["spline.js"],"names":["SplineInterpolator","grid","gridX","gridY","x0","x1","x2","width","x3","y0","y1","y2","height","y3","p00","p01","p02","p03","p10","p11","p12","p13","p20","p21","p22","p23","p30","p31","p32","p33","columnInterpolator0","ConstraintedSplineInterpolator","columnInterpolator1","columnInterpolator2","columnInterpolator3","yFraction","p0","p1","p2","p3","gridOffset","a","b","c","d","x","bSlope","slope","cSlope","bSlope2","cSlope2","kd","kc","kb","ka","yPrev","y","yNext","prevSlope","postSlope"],"mappings":"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","file":"spline.js","sourcesContent":["import {getGridValue} from '../util'\n\n/**\n * A 2D constrained spline interpolator.\n * For a 4x4 grid of samples, this allows us to calculate interpolated values between the central four samples.\n * By pre-fitting the curves in one dimension (y) and proceeding with the interpolation row by row,\n * we re-use most of the computation from one output pixel to the next.\n *\n * Polynomial (e.g. bicubic) interpolation is prone to oscillation and overshoot.\n * Splines are better behaved but can still overshoot. We can sacrifice smoothness and add a no-overshoot constraint.    * See: http://www.korf.co.uk/spline.pdf\n * Kruger, CJC. Constrained Cubic Spline Interpolation for Chemical Engineering Applications.\n */\nconst SplineInterpolator = (grid, gridX, gridY) => {\n  // First, find grid coordinates for the sixteen cells.\n  // The patch extends one cell east and south of the specified grid position, but uses 16 cells in the grid.\n  // We deal with the edges of the input grid by duplicating adjacent values.\n  // It's tempting to do this with typed arrays and slice(), but we need special handling for those grid edges.\n\n  const x0 = (gridX === 0) ? gridX : gridX - 1 // Handle left edge\n  const x1 = gridX\n  const x2 = (gridX + 1 >= grid.width) ? gridX : gridX + 1 // Handle right edge\n  const x3 = (gridX + 2 >= grid.width) ? gridX : gridX + 2 // Handle right edge\n\n  const y0 = (gridY === 0) ? gridY : gridY - 1 // Handle top edge\n  const y1 = gridY\n  const y2 = (gridY + 1 >= grid.height) ? gridY : gridY + 1 // Handle bottom edge\n  const y3 = (gridY + 2 >= grid.height) ? gridY : gridY + 2 // Handle bottom edge\n\n  const p00 = getGridValue(grid, x0, y0)\n  const p01 = getGridValue(grid, x0, y1)\n  const p02 = getGridValue(grid, x0, y2)\n  const p03 = getGridValue(grid, x0, y3)\n\n  const p10 = getGridValue(grid, x1, y0)\n  const p11 = getGridValue(grid, x1, y1)\n  const p12 = getGridValue(grid, x1, y2)\n  const p13 = getGridValue(grid, x1, y3)\n\n  const p20 = getGridValue(grid, x2, y0)\n  const p21 = getGridValue(grid, x2, y1)\n  const p22 = getGridValue(grid, x2, y2)\n  const p23 = getGridValue(grid, x2, y3)\n\n  const p30 = getGridValue(grid, x3, y0)\n  const p31 = getGridValue(grid, x3, y1)\n  const p32 = getGridValue(grid, x3, y2)\n  const p33 = getGridValue(grid, x3, y3)\n\n  // Create interpolations through each of the four columns\n  const columnInterpolator0 = ConstraintedSplineInterpolator(p00, p01, p02, p03)\n  const columnInterpolator1 = ConstraintedSplineInterpolator(p10, p11, p12, p13)\n  const columnInterpolator2 = ConstraintedSplineInterpolator(p20, p21, p22, p23)\n  const columnInterpolator3 = ConstraintedSplineInterpolator(p30, p31, p32, p33)\n\n  return function (yFraction) {\n    // Perform curve fitting in the second (x) dimension based on the pre-fit curves in the y dimension.\n    const p0 = columnInterpolator0(yFraction)\n    const p1 = columnInterpolator1(yFraction)\n    const p2 = columnInterpolator2(yFraction)\n    const p3 = columnInterpolator3(yFraction)\n    // Return the one-dimensional interpolator for this row.\n    return ConstraintedSplineInterpolator(p0, p1, p2, p3)\n  }\n}\nSplineInterpolator.gridOffset = 0.5\nexport default SplineInterpolator\n\n/**\n * Given four adjacent values a, b, c, d, fit a constrained cubic spline to them,\n * sacrificing smoothness to prevent overshoot.\n * The returned function provides interpolated values between b and c using a and d to\n * determine the slope going into and out of the b-c interval.\n * The original paper handles the general case where data points are (x,y) pairs.\n * In our case, the four points are always evenly spaced, so we assign X coordinates of\n * -1, 0, 1, 2 knowing we will perform interpolation between the second and third points.\n * This greatly simplifies the equations, because it gives many differences, multipliers,\n * and denominators have a value of 1.\n */\nconst ConstraintedSplineInterpolator = (a, b, c, d) => {\n  // Optimization: if b and c are equal, interpolate a straight line\n  if (b === c) return (x) => b\n  const bSlope = slope(a, b, c)\n  const cSlope = slope(b, c, d)\n  const bSlope2 = -(2 * cSlope + 4 * bSlope) + (6 * (c - b)) // equation 8\n  const cSlope2 = +(4 * cSlope + 2 * bSlope) - (6 * (c - b)) // equation 9\n  const kd = (cSlope2 - bSlope2) / 6                        // equation 10\n  const kc = bSlope2 / 2                                    // equation 11\n  const kb = (c - b) - kc - kd                              // equation 12\n  const ka = b                                              // equation 13\n  // The returned function takes an x value in [0, 1] expressing the position between b and c,\n  // and returns the interpolated value.\n  return (x) => ka + (kb * x) + (kc * (x ** 2)) + (kd * (x ** 3))\n}\n\n/**\n * This function implements equation 7a from the original constrained spline interpolation paper.\n * It finds the target slope at a particular data point. y here is the same as y sub i in the equations in the paper.\n * yPrev here is y sub i-1 and yNext here is y sub i+1.\n * The equations are simplified significantly by the fact that we know all of our points are exactly one unit apart.\n * We don't have a separate equation for slope at the endpoints (which requries recursively computing slopes).\n * Instead we just duplicate the values at the edge of the grid.\n */\nconst slope = function (yPrev, y, yNext) {\n  const prevSlope = y - yPrev\n  const postSlope = yNext - y\n  if (prevSlope === 0 || postSlope === 0) return 0 // necessary condition for no overshoot\n  if (Math.sign(prevSlope) !== Math.sign(postSlope)) return 0 // includes case where only one slope is zero\n  return 2 / (1 / postSlope + 1 / prevSlope)\n}\n"]}