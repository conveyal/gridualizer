{"version":3,"sources":["bilinear.js"],"names":["BilinearInterpolator","grid","gridX","gridY","upperLeft","lowerLeft","upperRight","lowerRight","leftIntercept","leftRise","rightIntercept","rightRise","yFraction","left","right","rowIntercept","rowRise","xFraction","gridOffset"],"mappings":";;;;;;AAAA;;AAEA;;;;;AAKA,IAAMA,uBAAuB,SAAvBA,oBAAuB,CAACC,IAAD,EAAOC,KAAP,EAAcC,KAAd,EAAwB;AACnD;AACA,MAAMC,YAAY,wBAAaH,IAAb,EAAmBC,QAAQ,CAA3B,EAA8BC,QAAQ,CAAtC,CAAlB;AACA,MAAME,YAAY,wBAAaJ,IAAb,EAAmBC,QAAQ,CAA3B,EAA8BC,QAAQ,CAAtC,CAAlB;AACA,MAAMG,aAAa,wBAAaL,IAAb,EAAmBC,QAAQ,CAA3B,EAA8BC,QAAQ,CAAtC,CAAnB;AACA,MAAMI,aAAa,wBAAaN,IAAb,EAAmBC,QAAQ,CAA3B,EAA8BC,QAAQ,CAAtC,CAAnB;AACA;AACA,MAAMK,gBAAgBJ,SAAtB;AACA,MAAMK,WAAWJ,YAAYD,SAA7B;AACA,MAAMM,iBAAiBJ,UAAvB;AACA,MAAMK,YAAYJ,aAAaD,UAA/B;AACA;AACA;AACA,SAAO,UAACM,SAAD,EAAe;AACpB;AACA,QAAMC,OAAOL,gBAAgBC,WAAWG,SAAxC;AACA,QAAME,QAAQJ,iBAAiBC,YAAYC,SAA3C;AACA,QAAMG,eAAeF,IAArB;AACA,QAAMG,UAAUF,QAAQD,IAAxB;AACA;AACA,WAAO,UAACI,SAAD;AAAA,aAAeF,eAAeC,UAAUC,SAAxC;AAAA,KAAP;AACD,GARD;AASD,CAtBD;AAuBAjB,qBAAqBkB,UAArB,GAAkC,GAAlC;kBACelB,oB;;AAEf;AACA;AACA;AACA;AACA","file":"bilinear.js","sourcesContent":["import {getGridValue} from '../util'\n\n/**\n * A bilinear interpolation patch for a 2x2 grid of samples.\n * Lines are pre-fit in one dimension (y) and interpolation proceeds row by row,\n * re-using most of the computation from one output pixel to the next.\n */\nconst BilinearInterpolator = (grid, gridX, gridY) => {\n  // Get a patch extending one cell east and south of the given grid location.\n  const upperLeft = getGridValue(grid, gridX + 0, gridY + 0)\n  const lowerLeft = getGridValue(grid, gridX + 0, gridY + 1)\n  const upperRight = getGridValue(grid, gridX + 1, gridY + 0)\n  const lowerRight = getGridValue(grid, gridX + 1, gridY + 1)\n  // Store enough information to interpolate along the left and right edges of the 2x2 box\n  const leftIntercept = upperLeft\n  const leftRise = lowerLeft - upperLeft\n  const rightIntercept = upperRight\n  const rightRise = lowerRight - upperRight\n  // For a given y position inside the patch in [0, 1],\n  // The bilinear interpolator returns a 1D interpolator for that single row.\n  return (yFraction) => {\n    // Fit a line in the second dimension (x) based on the pre-fit curves in the y dimension.\n    const left = leftIntercept + leftRise * yFraction\n    const right = rightIntercept + rightRise * yFraction\n    const rowIntercept = left\n    const rowRise = right - left\n    // return a 1D linear interpolator for a single row.\n    return (xFraction) => rowIntercept + rowRise * xFraction\n  }\n}\nBilinearInterpolator.gridOffset = 0.5\nexport default BilinearInterpolator\n\n// TODO optimization\n//        // Do not bother calculating cell if all corners are zero.\n//        if (upperLeft === upperRight === lowerLeft === lowerRight)\n//           this.getInterpolatedValue = () -> {return upperLeft}\n// Could also skip entire patches, drawing nothing into the tile.\n"]}