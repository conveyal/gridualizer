{"version":3,"sources":["bicubic.js"],"names":["BicubicInterpolator","grid","gridX","gridY","x0","x1","x2","width","x3","y0","y1","y2","height","y3","p00","p01","p02","p03","p10","p11","p12","p13","p20","p21","p22","p23","p30","p31","p32","p33","columnInterpolator0","CubicHermiteInterpolator","columnInterpolator1","columnInterpolator2","columnInterpolator3","yFraction","p0","p1","p2","p3","gridOffset","a","b","c","d","c3","c2","c1","c0","fraction"],"mappings":"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","file":"bicubic.js","sourcesContent":["import {getGridValue} from '../util'\n\n/**\n * A pre-calculated bicubic interpolation patch.\n * For a 4x4 grid of samples, this allows us to calculate interpolated values between the central four samples.\n * By pre-fitting the curves in one dimension (y) and proceeding with the interpolation row by row,\n * we re-use most of the computation from one output pixel to the next.\n */\nconst BicubicInterpolator = (grid, gridX, gridY) => {\n  // First, find grid coordinates for the sixteen cells.\n  // Produces a bicubic interpolation patch for a one-cell square.\n  // The patch extends one cell east and south of the specified grid position, but uses 16 cells in the grid.\n\n  // Deal with the edges of the input grid by duplicating adjacent values.\n  // It's tempting to do this with typed arrays and slice(), but we need special handling for the grid edges.\n  const x0 = (gridX === 0) ? gridX : gridX - 1 // Handle left edge\n  const x1 = gridX\n  const x2 = (gridX + 1 >= grid.width) ? gridX : gridX + 1 // Handle right edge\n  const x3 = (gridX + 2 >= grid.width) ? gridX : gridX + 2 // Handle right edge\n\n  const y0 = (gridY === 0) ? gridY : gridY - 1 // Handle top edge\n  const y1 = gridY\n  const y2 = (gridY + 1 >= grid.height) ? gridY : gridY + 1 // Handle bottom edge\n  const y3 = (gridY + 2 >= grid.height) ? gridY : gridY + 2 // Handle bottom edge\n\n  const p00 = getGridValue(grid, x0, y0)\n  const p01 = getGridValue(grid, x0, y1)\n  const p02 = getGridValue(grid, x0, y2)\n  const p03 = getGridValue(grid, x0, y3)\n\n  const p10 = getGridValue(grid, x1, y0)\n  const p11 = getGridValue(grid, x1, y1)\n  const p12 = getGridValue(grid, x1, y2)\n  const p13 = getGridValue(grid, x1, y3)\n\n  const p20 = getGridValue(grid, x2, y0)\n  const p21 = getGridValue(grid, x2, y1)\n  const p22 = getGridValue(grid, x2, y2)\n  const p23 = getGridValue(grid, x2, y3)\n\n  const p30 = getGridValue(grid, x3, y0)\n  const p31 = getGridValue(grid, x3, y1)\n  const p32 = getGridValue(grid, x3, y2)\n  const p33 = getGridValue(grid, x3, y3)\n\n  // Create interpolations through each of the four columns\n  // Supply an unrolled row-major grid of 16 values (a 4x4 grid).\n  // The resulting object can be used to interpolate between the inner four cells.\n  // Maybe we should be initializing this with a typed 2D array instead of this mess of individual variables.\n  const columnInterpolator0 = CubicHermiteInterpolator(p00, p01, p02, p03)\n  const columnInterpolator1 = CubicHermiteInterpolator(p10, p11, p12, p13)\n  const columnInterpolator2 = CubicHermiteInterpolator(p20, p21, p22, p23)\n  const columnInterpolator3 = CubicHermiteInterpolator(p30, p31, p32, p33)\n\n  return function (yFraction) {\n    // Perform curve fitting in the second (x) dimension based on the pre-fit curves in the y dimension.\n    const p0 = columnInterpolator0(yFraction)\n    const p1 = columnInterpolator1(yFraction)\n    const p2 = columnInterpolator2(yFraction)\n    const p3 = columnInterpolator3(yFraction)\n    // Return the one-dimensional interpolator for this row.\n    return CubicHermiteInterpolator(p0, p1, p2, p3)\n  }\n}\nBicubicInterpolator.gridOffset = 0.5\nexport default BicubicInterpolator\n\n/**\n * Given four adjacent values a, b, c, d, fit a curve to them.\n * The returned function provides interpolated values between b and c using a and d to\n * determine the slope going into and out of the b-c interval.\n */\nconst CubicHermiteInterpolator = (a, b, c, d) => {\n  const c3 = -a / 2.0 + (3.0 * b) / 2.0 - (3.0 * c) / 2.0 + d / 2.0\n  const c2 = a - (5.0 * b) / 2.0 + 2.0 * c - d / 2.0\n  const c1 = -a / 2.0 + c / 2.0\n  const c0 = b\n  // This function takes a value in [0, 1] expressing the position between b and c,\n  // and returns the interpolated value.\n  return (fraction) => c3 * fraction ** 3 + c2 * fraction ** 2 + c1 * fraction + c0\n}\n"]}