{"version":3,"sources":["grid-tile-layer.js"],"names":["GridTileLayer","grid","interpolator","colorizer","normalize","trimmedMax","canvas","mercTileCoord","zoom","canvasContext","getContext","imageData","createImageData","width","height","mercPixelX","x","mercPixelY","y","zoomDifference","gridCellWidthInTilePixels","tileWidthInGridCells","tilePixelsPerGridCell","dilutionFactor","gridOffset","gxMin","Math","floor","west","gyMin","north","gxMax","ceil","gyMax","gridStep","gx","gy","patch","txMin","tyMin","txMax","tyMax","ty","row","tx","interpolatedValue","color","imgOffset","data","set","putImageData","Canvas"],"mappings":"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","file":"grid-tile-layer.js","sourcesContent":["import {TileLayer} from 'leaflet'\nimport {getTrimmedMax} from './util'\nimport nearest from './interpolators/nearest'\n\n/** Visualize a Grid of opportunity densities (the Grid class from Browsochrones) as map tiles. */\nexport default class GridTileLayer extends TileLayer.Canvas {\n  initialize (grid, interpolator, colorizer) {\n    this.grid = grid\n    this.interpolator = interpolator\n    this.colorizer = colorizer\n    // Find a maximum with outliers trimmed off only when needed, because it can take some time.\n    if (colorizer.normalize === true) this.trimmedMax = getTrimmedMax(grid)\n  }\n\n  /**\n   * Given a web Mercator x, y, and zoom values for a single tile, as well as an associated canvas object,\n   * visualize the grid cell counts falling within that tile as colors or dots on the canvas.\n   */\n  drawTile (canvas, mercTileCoord, zoom) {\n    const canvasContext = canvas.getContext('2d')\n    const imageData = canvasContext.createImageData(canvas.width, canvas.height)\n\n    // Convert web Mercator tile position to pixels relative to the left and the top of the world at its zoom level.\n    const mercPixelX = mercTileCoord.x * 256\n    const mercPixelY = mercTileCoord.y * 256\n\n    // Compute the divisor that will convert pixel (or tile) coordinates at the visual map tile zoom level\n    // to pixel (or tile) coordinates at the opportunity density grid's zoom level, i.e. the number of visual map\n    // pixels (or tiles) an opportunity grid pixel (or tile) is wide. This is always a power of two,\n    // so as an optimization we could just store the difference in zoom levels and scale using bitshift operators.\n    // When zoomDifference is non-positive (when we're really zoomed out) tileWidthInGridCells will be > 256 and\n    // gridCellWidthInTilePixels will be in (0..1).\n    const zoomDifference = zoom - this.grid.zoom\n    const gridCellWidthInTilePixels = 2 ** zoomDifference\n    const tileWidthInGridCells = 256 / gridCellWidthInTilePixels\n    const tilePixelsPerGridCell = gridCellWidthInTilePixels ** 2\n\n    // The dot colorizer requires its input to be normalized to the range [0..1] and saturates at 1.\n    // We don't show one dot per opportunity, we want to show one dot per N opportunities such that the probability\n    // of a dot appearing at our trimmedMax value is 1. This simply means dividing the values by the trimmedMax.\n    // However, as we zoom in these probabilities that are passed to the dot colorizer remain the same, probabilities\n    // in the range [0..1] but an increasing number of pixels that may be switched on or off fall within each grid cell.\n    // So as we zoom in and the resolution increases, each dot represents a smaller and smaller number of opportunities.\n    // At some zoom level, dependent on the trimmedMax we are normalizing to, a dot will represent less than one\n    // opportunity. This is undesirable because it can give the impression that some category of opportunities is very\n    // prevalent on the map when in fact it's just uniformly scarce.\n    // We want to hold the divisor (\"dilutionFactor\") constant at trimmedMax to create the visual impression that as\n    // we zoom in, dot density remains constant over a given geographic area. What we are effectively doing is\n    // dividing the raw interpolated density by the number of opportunities per dot, then by the number\n    // of pixels within a grid cell at the current zoom level to spread the probability over many pixels.\n    //   density / dilutionFactor\n    // = density / opportunitiesPerDot / tilePixelsPerGridCell\n    // = density / (opportunitiesPerDot * tilePixelsPerGridCell)\n    // dilutionFactor = opportunitiesPerDot * tilePixelsPerGridCell\n    // opportunitiesPerDot = dilutionFactor / tilePixelsPerGridCell ; opportunitiesPerDot >= 1\n    // dilutionFactor / tilePixelsPerGridCell >= 1\n    // dilutionFactor >= tilePixelsPerGridCell\n    let dilutionFactor = this.trimmedMax\n    // Force implicit opportunitiesPerDot >= 1\n    if (dilutionFactor < tilePixelsPerGridCell) dilutionFactor = tilePixelsPerGridCell\n\n    // Fall back on nearest neighbor when each grid cell covers one or less tile pixels.\n    // Also when each tile covers a fraction of a grid cell.\n    const interpolator = this.interpolator === null || zoomDifference <= 1 || zoomDifference > 8\n      ? nearest : this.interpolator\n\n    // Find the range of grid cells that contribute to the contents of the map tile we're rendering.\n    // Most interpolators consider the grid cell value to be at the center of the cell,\n    // so we need to hit one extra row of cells outside the tile.\n    const gridOffset = this.interpolator.gridOffset\n    const gxMin = Math.floor(mercPixelX / gridCellWidthInTilePixels - this.grid.west - gridOffset)\n    const gyMin = Math.floor(mercPixelY / gridCellWidthInTilePixels - this.grid.north - gridOffset)\n    const gxMax = Math.ceil(gxMin + tileWidthInGridCells + gridOffset)\n    const gyMax = Math.ceil(gyMin + tileWidthInGridCells + gridOffset)\n\n    // When zoomed far enough out, we can skip over some grid cells.\n    let gridStep = 1\n    if (zoomDifference < 0) gridStep = 2 ** -zoomDifference\n\n    // Iterate over all opportunity grid pixels that contribute to the contents of the map tile we're rendering.\n    // Due to the fact that mercator grid zoom level sizes are powers of two, when multiple opportunity grid\n    // cells fall within a map tile there are always an integer number of them and no partial overlaps.\n    // But for interpolation purposes, we work on boxes that are offset 1/2 cell to the east and south because\n    // we consider grid cell values to be at the center (rather than the corner) of those cells.\n    // FIXME maybe we should be adding half the gridStep to use the grid cell in the center of the range.\n    for (let gx = gxMin; gx < gxMax; gx += gridStep) {\n      for (let gy = gyMin; gy < gyMax; gy += gridStep) {\n        const patch = interpolator(this.grid, gx | 0, gy | 0)\n        // Iterate over all the output tile pixels covered by this patch.\n        // These are truncated to integers to handle the case where grid cells are smaller than tile pixels.\n        const txMin = ((gx - gxMin - gridOffset) * gridCellWidthInTilePixels) | 0\n        const tyMin = ((gy - gyMin - gridOffset) * gridCellWidthInTilePixels) | 0\n        const txMax = Math.ceil(txMin + gridCellWidthInTilePixels) | 0\n        const tyMax = Math.ceil(tyMin + gridCellWidthInTilePixels) | 0\n        for (let ty = tyMin; ty < tyMax; ty++) {\n          if (ty < 0 || ty > 255) continue\n          // Todo: refactor to iterate over relative x and y?\n          // Get a single-row 1d interpolator function from the 2d interpolator\n          const row = patch((ty - tyMin) / gridCellWidthInTilePixels)\n          for (let tx = txMin; tx < txMax; tx++) {\n            if (tx < 0 || tx > 255) continue\n            // TODO refactor to iterate over relative x and y?\n            let interpolatedValue = row((tx - txMin) / gridCellWidthInTilePixels)\n            if (this.colorizer.normalize === true) interpolatedValue /= dilutionFactor\n            const color = this.colorizer(interpolatedValue)\n            if (color[3] !== 0) {\n              // Resulting color has some opacity, write it into the tile\n              const imgOffset = (ty * 256 + tx) * 4\n              imageData.data.set(color, imgOffset)\n            }\n          }\n        }\n      }\n    }\n    canvasContext.putImageData(imageData, 0, 0)\n  }\n}\n"]}